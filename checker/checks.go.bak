package main

import (
	"fmt"
	"log"
	"os/exec"
	"path/filepath"
	"strings"
	"syscall"
	"time"

	"github.com/spf13/viper"
	"gopkg.in/mgo.v2/bson"
)

type Check struct {
	Name   string
	Script exec.Cmd
	Points map[int]int
}

type TeamCheck struct {
	Teamname string
	Ip       []string
	Checks   []Check
}

type CheckResult struct {
	Teamname string
	Ip       string
	Service  string
	Status   int
	Output   string
}

type EventDuration struct {
	Start time.Time
	End   time.Time
}

var EventClock EventDuration

func getScript(path string) exec.Cmd {
	dir, err := filepath.Abs(path)
	if err != nil {
		log.Fatal(err)
	}
	return *exec.Command(dir)
}

func getArgs(args string) []string {
	return strings.Split(args, " ")
}

func getPoints(name string) map[int]int {
	var p []int
	err := viper.UnmarshalKey(name, &p)
	if err != nil {
		fmt.Println(err)
	}
	points := make(map[int]int)
	for i, v := range p {
		points[i] = v
	}
	return points
}

func getConfig() []Check {
	viper.SetConfigName("checks")
	viper.AddConfigPath(".")
	err := viper.ReadInConfig()
	if err != nil {
		log.Fatal(fmt.Errorf("Fatal error config file: %s \n", err))
	}

	// Get Event details
	EventClock.End, err = time.Parse(time.UnixDate, viper.GetString("event_end_time"))
	if err != nil {
		log.Fatal(err)
	}
	// Run for 10 seconds if the end time is past already
	if time.Now().After(EventClock.End) {
		EventClock.End = time.Now().Add(time.Second * 10)
	}
	checksDir := viper.GetString("checks_dir")

	// Get Checks
	var checks []Check
	for n := range viper.GetStringMap("checks") {
		check := "checks." + n
		s := Check{
			Name:   viper.GetString(check + ".check_name"),
			Script: getScript(checksDir + "/" + viper.GetString(check+".filename")),
			Points: getPoints(check + ".points"),
		}
		// Get Arguments
		s.Script.Args = append(s.Script.Args, getArgs(viper.GetString(check+".args"))...)
		checks = append(checks, s)
	}
	return checks
}

func runCmd(team TeamCheck, status chan CheckResult, cmd exec.Cmd) {
	out, _ := cmd.Output()

	/*
		err := cmd.Run()
		if err != nil {
			status <- fmt.Sprintf("%s %s: %d", filepath.Base(cmd.Path), ip, cmd.ProcessState.Sys().(syscall.WaitStatus).ExitStatus())
		} else {
			status <- fmt.Sprintf("%s %s: %d", filepath.Base(cmd.Path), ip, cmd.ProcessState.Sys().(syscall.WaitStatus).ExitStatus())
		}
	*/
	// Will ignore error because an error means the check failed
	_ = cmd.Run()
	status <- CheckResult{
		Teamname: team.Teamname,
		Ip:       team.Ip,
		Service:  filepath.Base(cmd.Path),
		Status:   cmd.ProcessState.Sys().(syscall.WaitStatus).ExitStatus(),
		Output:   string(out),
	}
}

func start(timeout int, checks []TeamCheck) {
	EventClock.Start = time.Now()
	status := make(chan CheckResult)
	checkTicker := time.NewTicker(viper.GetDuration("intervals"))

	// Run command every x seconds until scheduled end time
	for t := range checkTicker.C {
		if time.Now().Before(EventClock.End) {
			//fmt.Printf("%s Running Checks\n", t)
			for _, team := range checks {
				for _, check := range team.Checks {
					go runCmd(team, status, check.Script)
				}
			}
			for j := 0; j < 8; j++ {
				select {
				case res := <-status:
					fmt.Printf("%s %s\nService: %s\tStatus: %d\n%s\n", res.Teamname, res.Ip, res.Service, res.Status, res.Output)
				case <-time.After(time.Second * 5):
					fmt.Println("Timed out")
				}
			}
		} else {
			checkTicker.Stop()
			fmt.Println("Done Checking Services")
			break
		}
	}
}

type Team struct {
	Id         bson.ObjectId
	Teamname   string
	Ips        []string
	Hash       string
	Teamnumber int
}

func getTeams() {
	teams := []Team{
		Team{
			Teamname: "Team1",
			Ips:      []string{"127.0.0.1"},
		},
		Team{
			Teamname: "Team2",
			Ips:      []string{"127.0.0.2"},
		},
	}
	for _, t := range teams {
		fmt.Printf("%s %s\n", t.Teamname, t.Ips[0])
	}
}

func score() {
	// Get Teamname and status
	// Based on status will insert points to team
}

func setup() {
	checks := getConfig()
	ips := []string{"150.156.188.14", "127.0.0.1", "104.18.49.172", "104.31.64.186"}
	timeout := 5
	var teamChecks []TeamCheck
	for _, ip := range ips {
		t := TeamCheck{
			Ip: ip,
		}
		for _, s := range checks {
			s.Script.Args = append(s.Script.Args, ip)
			t.Checks = append(t.Checks, s)
		}
		teamChecks = append(teamChecks, t)
	}
	start(timeout, teamChecks)
}

func pulse() {
	checks := getConfig()
}

func main() {
	//getTeams()
	setup()
	// Get Teamname, IPs, and points for status
}
